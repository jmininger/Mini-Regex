from util import Stack
import bisect


class NFAIterator:
    def __init__(self, substate, age):
        self.substate = substate
        self.age = age

    def __eq__(self, other):
        return self.age == other.age and self.substate.id == other.substate.id

    def __lt__(self, other):
        return self.age < other.age


class DFAState:
    def __init__(self):
        # List of active iterators all sorted by age
        self.partial_states = []
        self.explored = ()

    def add_iterator(self, iter):
        bisect.insort_right(self.partial_states, iter)
        self.explored.append(iter.substate.id)

    def is_explored(self, substate_id):
        return substate_id in self.explored

    def iterators_at_age(self, age):
        idx = self.partial_states.index(age)
        last_index = len(self.partial_state)\
            - self.partial_states[::-1].index(age)
        return self.partial_states[idx: last_index]

    def get_iterators(self):
        return self.partial_states


class DFASimulator:  # NFARunner?
    def __init__(self, nfa):
        # Constant fields
        self.nfa = nfa
        # Mutable fields
        self.current_age = 0
        self.dfa = DFAState()

        # iterators with ages in this set are invalid
        self.age_restrictions = set()

    def epsilon_closure(self, start_iter, dfa_state):
        # move explored to dfa_state
        explored = set()
        for dst in start_iter.substate.epsilon_paths():
            if dst.id not in explored:
                explored.append(dst.id)
                frontier.push(dst)
        while not frontier.is_empty():
            dst = frontier.top()
            frontier.pop()
            dfa_state.add_iterator(NFAIterator(dst, start_iter.age))
        return dfa_state

    def advance_multi_state(self, input):
        # prevents cycles and the access of nodes already occupied
        explored = set()
        next_state = DFAState()
        match = None
        self.dfa.add_iterator(NFAIterator(self.nfa.start, self.current_age))
        for iter in self.dfa.get_iterators():

            # If a match ending with the current char has been found, and if
            # all iterators of the same age have been updated, return the match
            if match and iter.age > match[0]:
                return match

            # Otherwise, begin a depth first search of all nodes reachable from
            # the current state
            frontier = Stack()
            for dst in iter.substate.available_paths(input):
                if dst.id not in explored:
                    explored.add(dst.id)
                    frontier.push(dst)
                    next_state.add_iterator(NFAIterator(dst, iter.age))

                # If a the edge leads to the final state, declare a match
                if dst.id == self.nfa.end.id:
                    for iter.age in range(iter.age+1, self.current_age):
                        self.age_restrictions.append(iter.age)
                    match = (iter.age, self.current_age)

            # Determine the epsilon closure of all destinations advanced from
            # the previous state
            while not frontier.is_empty():
                sub_state = frontier.top()
                frontier.pop()
                free_nodes = sub_state.epsilon_paths()
                for n in free_nodes:
                    if n.id not in explored:
                        explored.add(n.id)
                        frontier.push(n)
                        next_state.add_iterator(NFAIterator(n, iter.age))
                        # If the edge leads to the final state, declare a match
                    if dst.id == self.nfa.end.id:
                        for iter.age in range(iter.age+1, self.current_age):
                            self.age_restrictions.append(iter.age)
                        match = (iter.age, self.current_age)

        self.current_age += 1
        self.dfa = next_state
        print([iter.substate.id for iter in self.dfa.get_iterators()])
        return match
        # Have a state container that takes care of the mess and then program
        # to its interface

    def advance_state(self, input):
        explored = set()
        frontier = Stack()
        next_state = []
        for partial_state in self.dfa:
            for node in partial_state.available_paths(input):
                if node.id not in explored:
                    explored.add(node.id)
                    frontier.push(node)
                    next_state.append(node)
        # Now each node has moved once...so the next states and their
        # epsilon closure is the set of all nodes in the next state
        while not frontier.is_empty():
            node = frontier.top()
            frontier.pop()
            free_nodes = node.epsilon_paths()
            for n in free_nodes:
                if n.id not in explored:
                    explored.add(n.id)
                    frontier.push(n)
                    next_state.append(n)
        self.dfa = next_state
        return self.nfa.end.id in explored

    def reset(self):
        self.dfa = [self.nfa.start]

    def is_active(self):
        return len(self.dfa) != 0
